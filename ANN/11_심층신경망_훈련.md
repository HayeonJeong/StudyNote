# 11. 심층 신경망 훈련

Created time: May 2, 2024 9:24 PM
Subject: 인공신경망

---

복잡한 문제를 다룰 경우, 수백 개의 뉴런으로 구성된 10개 이상의 층을 수십만 개의 가중치로 연결해 깊은 인공 신경망을 훈련해야 할 것이다. 이러한 심층 신경망을 훈련하는 데 여러가지 문제가 생길 수 있다.

| 문제점 | 11장에서 알아볼 해결책 |
| --- | --- |
| 출력층에서 멀어질수록 gradient가 점점 작아지는 ‘소실’, 커지는 문제인 ‘폭주’가 나타날 수 있다. 두 문제 모두 하위 층을 훈련하기 매우 어렵게 만든다. | 해결 방법 |
| 훈련 데이터가 충분하지 않은 경우, 레이블 제작 비용이 많이 드는 경우 | 레이블된 데이터가 적을 때 복잡한 문제를 다루는 데 도움이 되는 ‘전이 학습’과 ‘비지도 사전 훈련’을 알아본다. |
| 훈련이 극단적으로 느려질 수 있다. | 훈련 속도를 크게 높여주는 다양한 최적화 방법 |
| 과대적합
1. 너무 많은 파라미터를 가진 모델
2. 훈련 샘플이 충분하지 않은 경우
3. 잡음이 많은 경우 | 규제 기법 |

# 11.1 Gradient 소실, 폭주 문제

- 10장 내용
    - Back propagation의 두 번째 단계는 출력층에서 입력층으로 ‘오차 그레디언트’를 전파하면서 진행된다.
    - 알고리즘이 신경망의 모든 파라미터에 대한 오차 함수의 gradient를 계산하면, 경사하강법 단계에서 이 gradient를 사용하여 각 파라미터를 수정한다.
- **그레디언트 소실_Vanishing Gradient**
    - 알고리즘이 하위층으로 진행될수록 gradient가 점점 작아지는 경우
    - 이러한 경우에 하위 층의 연결 가중치가 변경되지 않는데, 훈련이 좋은 솔루션으로 수렴되지 않을 것이다.
- **그레디언트 폭주_Exploding Gradient**
    - gradient가 점점 커져서 여러층이 비정상적으로 큰 가중치르 갱신되면 알고리즘은 발산(diverse)한다.
- 이런식으로 불안정한 gradient는 심층신경망 훈련을 어렵게 만든다.

---

- 이렇게 gradient를 불안정하게 하는 원인은?
    - logistic sigmoid 활성화 함수 + 가중치 초기화 방식 (평균이 0이고 표준편차가 1인 정규분포)
    - 이 활성화 함수와 초기화 방식을 사용했을 때, 각 층에서 출력의 분산이 입력의 분산보다 더 크다.
    - 신경망 위쪽으로 갈수록 층을 지날 때마다 분산이 계속 커져, 가장 높은 층에서는 활성화 함수가 0이나 1로 수렴한다.
        
        ![Untitled](11%20%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8E%E1%85%B3%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%E1%84%86%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AE%E1%86%AB%E1%84%85%E1%85%A7%E1%86%AB%20a9b5a561a9e149b68f06f45841b15bc6/Untitled.png)
        
        - sigmoid 함수의 평균이 0이 아니라 0.5. (항상 양수를 출력하니까 출력의 가중치 합이 입력보다 계속 커지는 것이다. = 편향 이동(bias shift))
            - tanh 함수는 평균이 0이므로 sigmoid 함수보다 조금 더 낫다.
        - 역전파가 될 때, 조금 있는 gradient는 최상위 층에서부터 역전파가 진행되면서 점차 약해져서 실제로 아래쪽 층에는 아무것도 도달하지 않게 된다.

## 11.1.1 글로럿 He 초기화

- 글로럿과 벤지오의 논문: 불안정한 그레디언트 문제를 완화하는 방법
    - 각 층의 출력에 대한 분산이 입력에 대한 분산과 같아야. (fan-in = fan-out)
        - fan-in (팬 인): 입력 개수
        - fan-out (팬 아웃): 출력 개수
    - 역방향에서 층을 통과하기 전과 후의 그레디언트 분산이 동일해야.
- 글로럿 초기화_Glorot initialization = 세이비어 초기화_Xavier initialization
    - 각 층의 연결 가중치를 랜덤으로 초기화
        
        ![Untitled](11%20%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8E%E1%85%B3%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%E1%84%86%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AE%E1%86%AB%E1%84%85%E1%85%A7%E1%86%AB%20a9b5a561a9e149b68f06f45841b15bc6/Untitled%201.png)
        
        ![Untitled](11%20%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8E%E1%85%B3%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%E1%84%86%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AE%E1%86%AB%E1%84%85%E1%85%A7%E1%86%AB%20a9b5a561a9e149b68f06f45841b15bc6/Untitled%202.png)
        
- 르쿤 초기화_LeCun initialization: fan_avg를 fan_in으로 바꾸기
    - fan_in = fan_out이면 르쿤 초기화가 글로럿 초기화와 동일
    - 훈련 속도를 높일 수 있다.
- He 초기화 = 카이밍 초기화_Kaiming initialization
    - ReLU 함수 사용
    
    ```python
    import tensorflow as tf
    
    dense = tf.kreas.layers.Dense(50, activation="relu",
    															kernel_initializer="he_normal")
    ```
    
    ```python
    he_avg_init = tf.keras.initializers.VarianceScaling(scale=2., mode="fan_avg",
    																										distribution="uniform")
    
    dense = tf.kreas.layers.Dense(50, activation="sigmoid",
    															kernel_initializer=he_avg_init)
    ```
    

---

![Untitled](11%20%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8E%E1%85%B3%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%E1%84%86%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AE%E1%86%AB%E1%84%85%E1%85%A7%E1%86%AB%20a9b5a561a9e149b68f06f45841b15bc6/Untitled%203.png)

- 케라스는 기본적으로 균등 분포의 글로럿 초기화를 사용.

## 11.1.2 고급 활성화 함수

- 활성화 함수를 잘못 선택하면, 자칫 그레디언트 소실이나 폭주로 이어질 수 있다.
- ReLU 함수는 뉴런의 방식과 비슷한 시그모이드 함수보다 심층 신경망에서 더 잘 작동함을 알아보았다.
- 하지만, ReLU는 일부 뉴런이 0 이외의 값을 출력하지 않아 완벽하지 않다.
    - 특히, 큰 학습률을 사용하면 신경망의 뉴런 절반이 죽어 있기도 하다.
    - 뉴런의 가중치가 바뀌어 훈련 세트에 있는 모든 샘플에 대해 ReLU 함수의 입력이 음수가 되면 뉴런이 죽게 된다.
- 그래서 아래와 같은 ReLU 함수의 변형을 사용하게 된다.

### LeakyReLU

![Untitled](11%20%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8E%E1%85%B3%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%E1%84%86%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AE%E1%86%AB%E1%84%85%E1%85%A7%E1%86%AB%20a9b5a561a9e149b68f06f45841b15bc6/Untitled%204.png)

$$
LeakyReLU_a(z) = max(\alpha z, z)
$$

- $\alpha$가 이 함수가 ‘새는(leak)’ 정도를 결정한다.
    - 새는 정도: $z < 0$ 일 때 함수의 기울기. 이 기울기가 LeakyReLU를 절대 죽지 않게 만들어준다.
    - 기울기가 클 때 조금 더 나은 성능을 냄 ($\alpha = 0.2$가 $\alpha=0.01$보다 나은 성능)
- RReLU_Randomized Leaky ReLU
    - 훈련하는 동안 주어진 범위에서 $\alpha$를 랜덤으로 선택하고 테스트 시에는 ‘평균’을 사용
    - 과대적합 위험을 줄이는 규제의 역할을 하는 것처럼 보임
- PReLU_parametric leaky ReLU
    - $\alpha$가 훈련하는 동안 학습됨
    - 하이퍼파라미터가 아니고, 다른 모델 파라미터와 같이 역전파에 의해 변경되는 것이다.
    - 대규모 데이터셋에서만 ReLU보다 성능이 앞서고, 소규모 데이터셋에서는 과대적합될 위험이 있음.

```python
# 활성화 함수를 별도의 층으로 모델에 추가할 수도 있음. (훈련과 예측 시 차이는 없음)
model = tf.keras.models.Sequential([
	[...] # 다른 층
	tf.keras.layers.Dense(50, kernel_initializer="he_normal"), # 활성화 함수 없음
	tf.keras.layers.LeakyReLU(alpha=0.2), # 별도의 활성화 함수 층
	[...] # 다른 층
])
```

### ELU와 SELU

- ReLU, LeakyReLU, PReLU의 도함수(기울기)는 $z = 0$에서 갑자기 바뀐다.
- 이러한 불연속성은 경사하강법을 최적점에서 진동하게 만들거나 수렴을 느리게 만들 수 있다.
- 그래서 ELU, SELU와 같은 ReLU의 부드러운 변형이 나왔다.
- ELU_exponential linear unit
    
    ![Untitled](11%20%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8E%E1%85%B3%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%E1%84%86%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AE%E1%86%AB%E1%84%85%E1%85%A7%E1%86%AB%20a9b5a561a9e149b68f06f45841b15bc6/Untitled%205.png)
    
    - 단점
        - 지수 함수를 사용하므로 ReLU나 그 변형들보다 계산이 느리다.
        - 훈련하는 동안에는 수렴 속도가 빨라서 느린 계산이 상쇄될 수 있지만, 테스트 시에는 ELU를 사용한 네트워크가 ReLU를 사용한 네트워크보다 느릴 것.

---

![Untitled](11%20%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8E%E1%85%B3%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%E1%84%86%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AE%E1%86%AB%E1%84%85%E1%85%A7%E1%86%AB%20a9b5a561a9e149b68f06f45841b15bc6/Untitled%206.png)

---

- SELU_Scaled ELU
    - 스케일이 조정된 ELU 활성화 함수
    - MLP(특히 아주 깊은 네트워크)의 모든 은닉 층이 SELU를 사용한다면, 네트워크가 자기 정규화 된다.
        - 자기 정규화의 조건
            1. 훈련하는 동안 각 층의 출력이 평균 0, 표준 편차 1 유지 (SELU는 유지하기 때문에 자기 정규화)
                - 그레디언트 소실, 폭주 문제를 막아준다.
            2. 모든 은닉 층의 가중치는 ‘르쿤 정규 분포 초기화’로 초기화되어야.
            3. 일반적인 MLP에서만 보장됨. (스킵 연결과 같은 다루 구조에는 ELU보다 뛰어나지 않음)
            4. $l_1$, $l_2$ 규제, 맥스-노름, 배치 정규화, 드롭아웃과 같은 규제를 사용할 수 없음.
        - 이러한 제약이 크기 때문에 좋은 성질을 가짐에도 큰 관심을 얻지 못함.
        - 아래에서 설명할 GELU, Swish, Mish 활성화 함수가 대부분의 작업에서 일관되게 더 나은 성능을 발휘.

### GELU, Swish, Mish

![Untitled](11%20%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8E%E1%85%B3%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%E1%84%86%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AE%E1%86%AB%E1%84%85%E1%85%A7%E1%86%AB%20a9b5a561a9e149b68f06f45841b15bc6/Untitled%207.png)

- GELU: ReLU의 부드러운 변형
    
    $$
    GELU(z) = z\Phi(z)
    $$
    
    - $\Phi(z)$: 표준 가우스 누적 분포 함수_cumulativ distribution function(CDF) = 평균이 0이고 분산이 1인 정규 분포에서 랜덤하게 샘플링한 값이 $z$보다 작을 확률
    - 지금까지의 모든 활성화 함수는 convex monotonic(볼록한 단조) 함수이지만, GELU는 둘 다 아니다.
        - 왼쪽에서 직선으로 시작해서, 아래로 구부러지다가, -0.17에서 저점에 도달한다. 그리고 마지막에 상승하여 오른쪽 위로 직진한다.
        - 이런 복잡한 모양과 모든 위치에 곡률이 있기 때문에 복잡한 작업에서 이 함수가 잘 작동하는 것.
        - 경사하강법이 복잡한 패턴을 학습하기 쉬워지는 것.
    - 단점: 계산량이 많다. (성능 향상이 추가 비용을 정당화하기에 항상 충분하지는 않다.)
- SiLU_sigmoid linear unit = Swish
    
    $$
    Swish_\beta(z) = z\sigma(\beta z)
    $$
    
    - $\beta = 1.702$를 사용하는 일반화된 Swish 함수 → GELU
    - 다른 하이퍼파라미터처럼 $\beta$를 튜닝할 수 있음
    - $\beta$를 훈련 가능한 파라미터로 만들고 경사 하강법으로 최적화할 수도 있음. (PReLU와 마찬가지로 과대적합 위험)
- Mish
    
    $$
    mish(z) = ztanh(softplus(z))
    $$
    
    $$
    softplus(z) = log(1 + exp(z))
    $$
    
    - 볼록하지 않고 단조 함수가 아닌 ReLU의 변형
    - Swish보다 근소한 차이로 더 나은 성능 발휘
    - z가 음수일 때 Swish와 거의 완벽하게 겹치고, z가 양수일 때 GELU와 거의 완벽하게 겹침
- 그래서 심층 신경망의 hidden layer에 어떤 활성화 함수를 사용해야하나? (keras)
    - 간단한 작업에는 ReLU가 기본값
    - ~~복잡한 작업에는 Swish (keras 지원 X)~~
        - ~~가장 복잡한 작업에는 학습 가능한 $\beta$ 파라미터를 가진 Swish~~
    - ~~Mish는 조금 더 나은 결과를 얻을 수 있지만 계산량이 좀 더 많음 (keras 지원 X)~~
    - 실행 속도가 중요한 경우 LeakyReLU
    - 심층 MLP의 경우 SELU (제약 조건 반드시 준수)
    - 시간, 컴퓨팅 성능에 여유 있으면 ‘교차 검증’을 사용하여 다른 활성화 함수도 평가.

## 11.1.3 배치 정규화

- 활성화 함수 + 초기화 방법 변경으로 훈련 ‘초기’ 단계에서 그레디언트 소실과 폭주 문제를 줄일 수 있지만, 훈련하는 동안 다시 발생하지 않으리란 보장은 없다.
- 배치 정규화_batch normalization(BN)
    - 각 층에서 활성화 함수를 통과하기 전이나 후에 연산을 하나 추가하는 것.
    - 입력을 원점에 맞추고 정규화 → 각 층에서 두 개의 새로운 파라미터로 결괏값의 스케일을 조정하고 이동
        - 파라미터 1: 스케일 조정
        - 파라미터 2: 이동
    - 신경망의 첫 번째 층으로 배치 정규화를 추가하면, 훈련 세트를 표준화할 필요가 없음
        - StandardScaler, Normalization 클래스가 필요하지 않을 것.
        - StandardScaler는 훈련 데이터의 평균과 표준 편차를 사용하여 데이터를 정규화하는 반면, 배치 정규화는 훈련 데이터를 사용하여 훈련 중에 평균과 표준 편차를 추정하고, 이를 사용하여 입력을 정규화한다. 그래서 테스트(예측) 시에는 추가적인 데이터 전처리 과정이 필요하다.
            
            <aside>
            <img src="11%20%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8E%E1%85%B3%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%E1%84%86%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AE%E1%86%AB%E1%84%85%E1%85%A7%E1%86%AB%20a9b5a561a9e149b68f06f45841b15bc6/KakaoTalk_Photo_2024-05-04-19-46-47.png" alt="11%20%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8E%E1%85%B3%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%E1%84%86%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AE%E1%86%AB%E1%84%85%E1%85%A7%E1%86%AB%20a9b5a561a9e149b68f06f45841b15bc6/KakaoTalk_Photo_2024-05-04-19-46-47.png" width="40px" />     StandardScaler는 전체 데이터셋의 평균과 표준 편차를 계산한 후에 이를 사용하여 데이터를 정규화합니다. 즉, 훈련 과정에서 전체 데이터셋을 보고 평균과 표준 편차를 계산한 후, 이를 사용하여 모든 데이터를 정규화합니다.
            
                한편, 배치 정규화는 각 층에서의 입력을 정규화하는 과정을 말해요. 훈련 중에 각 미니배치의 평균과 표준 편차를 계산하고, 이를 사용하여 입력을 정규화합니다. 이것은 네트워크의 안정성을 향상시키고 학습 속도를 높이는 데 도움이 됩니다. 따라서 StandardScaler와 배치 정규화는 데이터를 정규화하는 목적은 비슷하지만, 적용하는 방식과 시점이 다릅니다.
            
            </aside>
            
            <aside>
            <img src="11%20%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8E%E1%85%B3%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%E1%84%86%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AE%E1%86%AB%E1%84%85%E1%85%A7%E1%86%AB%20a9b5a561a9e149b68f06f45841b15bc6/KakaoTalk_Photo_2024-05-04-19-46-47%201.png" alt="11%20%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8E%E1%85%B3%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%E1%84%86%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AE%E1%86%AB%E1%84%85%E1%85%A7%E1%86%AB%20a9b5a561a9e149b68f06f45841b15bc6/KakaoTalk_Photo_2024-05-04-19-46-47%201.png" width="40px" />     "배치" 정규화라는 용어는 조금 혼란스러울 수 있어요. 배치 정규화는 일반적으로 미니배치(mini-batch) 데이터를 기반으로 하기 때문에 이러한 이름이 붙었습니다. 하지만 배치 정규화는 실제로 미니배치의 크기에만 의존하는 것이 아니라, 각 층의 입력에 대한 통계적 정규화를 수행하는 개념입니다.
            
                이름에서 유래한 혼동을 피하기 위해, "층 정규화(Layer Normalization)"나 "그룹 정규화(Group Normalization)" 등과 같은 용어가 사용되기도 합니다. 이러한 용어들은 각각 층 단위로 정규화하거나 입력을 그룹 단위로 나누어 정규화하는 다른 정규화 방법을 나타냅니다.
            
                결국, "배치" 정규화는 주로 미니배치 데이터를 사용하여 입력을 정규화하지만, 이것이 정확한 용어인지는 조금 논란이 될 수 있습니다.
            
            </aside>
            

---

![Untitled](11%20%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8E%E1%85%B3%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%E1%84%86%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AE%E1%86%AB%E1%84%85%E1%85%A7%E1%86%AB%20a9b5a561a9e149b68f06f45841b15bc6/Untitled%208.png)

---

- 테스트 시에는 어떻게 할까?
    - 샘플의 배치가 아니라 샘플 하나에 대한 예측을 만들어야 한다. 이러한 경우에는 입력의 평균과 표준 편자를 계산할 방법이 없다.
    - 훈련이 끝난 후, 전체 훈련 세트를 신경망에 통과시켜 배치 정규화 층의 각 입력에 대한 평균과 표준편차를 계산하면 된다.
    - 그러나 대부분 배치 정규화 구현은 층의 입력 평균과 표준 편차의 ‘이동 평균’을 사용해, 훈련하는 동안 최종 통계를 추정한다. 케라스의 BatchNormalization 층은 이를 자동으로 수행한다.
- 그레디언트 소실 문제 감소에 더불어 드롭아웃과 같은 규제 역할을 한다. 다른 규제 기법의 필요성을 줄여주는 것이다.
    - 배치 정규화는 전체 데이터셋이 아니라 미니배치마다 평균과 표준 편차를 계산하므로 훈련 데이터에 일종의 ‘잡음’을 넣는다고 볼 수 있다.
    - 이런 잡음은 훈련 세트에 과대적합되는 것을 방지하는 규제의 효과를 가지며, 미니배치의 크기가 클수록 효과는 줄어든다.
    - 하지만 부수 효과이기 때문에 드롭아웃과 함께 사용하는 것이 좋긴 하다.
- 성능과 시간
    - 에포크마다 더 많은 시간이 걸리므로, 훈련이 오히려 느려질 수 있다.
    - 하지만, 수렴이 더 빨라지므로 보통 상쇄된다.
    - 더 적은 에포크로 동일한 성능에 도달할 수 있어, 대부분 실제로 걸리는 시간은 더 짧다.

### 케라스로 배치 정규화 구현하기

- 활성화 함수 이전에 배치 정규화 층 추가하기
    
    ```python
    model = tf.keras.Sequential([
        # 입력층
        tf.keras.layers.Input(shape=(28, 28)),
    
        # 첫 번째 은닉층
        tf.keras.layers.BatchNormalization(),  # 배치 정규화
        tf.keras.layers.Dense(300, activation='relu', kernel_initializer='he_normal'),  # 300개의 뉴런, ReLU 활성화 함수, He 초기화
    
        # 두 번째 은닉층
        tf.keras.layers.BatchNormalization(),  # 배치 정규화
        tf.keras.layers.Dense(300, activation='relu', kernel_initializer='he_normal'),  # 300개의 뉴런, ReLU 활성화 함수, He 초기화
    
        # 세 번째 은닉층
        tf.keras.layers.BatchNormalization(),  # 배치 정규화
        tf.keras.layers.Dense(300, activation='relu', kernel_initializer='he_normal'),  # 300개의 뉴런, ReLU 활성화 함수, He 초기화
    
        # 출력층
        tf.keras.layers.Dense(10, activation='softmax')  # 10개의 뉴런, 소프트맥스 활성화 함수
    ])
    ```
    
- 활성화 함수 이후에 배치 정규화 층 추가하기
    
    ```python
    model = tf.keras.Sequential([
        # 입력층
        tf.keras.layers.Input(shape=(28, 28)),
    
        # 첫 번째 은닉층
        tf.keras.layers.Dense(300, kernel_initializer='he_normal'),  # 300개의 뉴런, He 초기화
        tf.keras.layers.BatchNormalization(),  # 배치 정규화
        tf.keras.layers.Activation('relu'),  # ReLU 활성화 함수
    
        # 두 번째 은닉층
        tf.keras.layers.Dense(300, kernel_initializer='he_normal'),  # 300개의 뉴런, He 초기화
        tf.keras.layers.BatchNormalization(),  # 배치 정규화
        tf.keras.layers.Activation('relu'),  # ReLU 활성화 함수
    
        # 세 번째 은닉층
        tf.keras.layers.Dense(300, kernel_initializer='he_normal'),  # 300개의 뉴런, He 초기화
        tf.keras.layers.BatchNormalization(),  # 배치 정규화
        tf.keras.layers.Activation('relu'),  # ReLU 활성화 함수
    
        # 출력층
        tf.keras.layers.Dense(10, activation='softmax')  # 10개의 뉴런, 소프트맥스 활성화 함수
    ])
    ```
    
- BatchNormalization의 하이퍼파라미터
    - momentum: 지수 이동 평균을 업데이트할 때 사용
        - $\hat{v} \leftarrow \hat{v}\times momentum + v \times (1-momentum)$
    - axis: 정규화할 축을 결정 (기본값은 -1, 마지막 축을 정규화.)
        - 입력 배치가 2D([샘플 개수, 특성 개수])
            - 각 입력 특성이 (배치에 있는 모든 샘플에 대해 계산한 평균과 표준편차를 기반으로) 정규화.
        - 입력 배치가 3D([샘플 개수, 높이, 너비]): 배치 정규화 층을 Flatten 층 이전으로 옮길 경우.
            1. 배치 정규화 층이 28개의 평균과 28개의 표준 편차를 계산.
            2. 그 다음, 동일한 평균과 표준 편차를 사용하여 해당 열의 모든 픽셀을 정규화한다.
            3. 784개 픽셀을 독립적으로 다루고 싶다면 axis=[1, 2]로 지정해야.
- CNN의 모든 층 뒤에 배치 정규화가 있는 것으로 가정함. (매우 널리 사용해서, 종종 신경망 그림에서 빠져있음.)

## 11.1.4 그레디언트 클리핑_gradient clipping

- 역전파될 때 특정 임계값을 넘어서지 못하도록 그레디언트를 잘라내는 것.
- 일반적으로 배치 정규화를 사용하기 까다로운 순환 신경망에서 사용됨.

```python
optimizer = tf.keras.optimizers.SGD(clipvalue=1.0) # cliipnorm 매개변수 지정
model.compile([...], optimizer=optimizer)
```

- 위 코드는, 훈련되는 각 파라미터에 대한 ‘손실의 모든 편미분값’을 -1.0에서 1.0으로 잘라냄.
    - 원래 그레디언트 벡터가 [0.9, 100.0]이라면 대부분 2번째 축 방향을 향하는데,
    - 위 코드를 기반으로 클리핑되면 [0.9, 1.0]이 되고, 거의 두 축 사이 대각선 방향을 향한다.
- 만약, 그레디언트 클리핑이 그레디언트 벡터의 방향을 바꾸지 못하게 하려면 clipvalue 대신 clipnorm을 지정하여 노름으로 클리핑해야 한다.

# 11.2 사전 훈련된 층 재사용하기

- 전이 학습_transfer learning: 훈련 속도를 높이고, 필요한 훈련 데이터도 크게 줄여줌.
- 만약 입력 이미지 크기가 다르다면, 원본 모델에 맞는 크기로 변경하는 ‘전처리’ 단계를 추가해야 한다.

![Untitled](11%20%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8E%E1%85%B3%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%E1%84%86%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AE%E1%86%AB%E1%84%85%E1%85%A7%E1%86%AB%20a9b5a561a9e149b68f06f45841b15bc6/Untitled%209.png)

- 작업이 비슷할수록 (낮은 층부터 시작해서) 더 많은 층을 재사용하자. 아주 비슷한 작업이면 모든 은닉 층을 유지하고 출력 층만 교체하면 된다.
    - 원본 모델의 상위 은닉 층은 하위 은닉 층보다 덜 유용하기 때문.
- 재사용할 층 개수를 어떻게 선정?
    1. 재사용하는 층을 모두 동결 (가중치 고정)
    2. 모델 훈련 및 성능 평가
    3. 맨 위에 있는 1-2개의 은닉층 동결을 해제하고 역전파를 통해 가중치를 조절하여 성능이 향상되는지 확인
        1. 훈련 데이터가 많을수록 많은 층의 동결을 해제할 수 있음.
        2. 학습률을 줄이는게 좋음. (가중치를 세밀하게 튜닝하는 데 도움이 됨.)
    4. 여전히 좋은 성능이 안나오고 훈련 데이터가 적다면, 상위 은닉층들을 제거하고 남은 은닉층을 다시 동결해보자.
    5. 재사용할 은닉 층의 개수를 찾을 때까지 반복하기.
    6. 훈련 데이터가 아주 많다면 오히려 은닉 층을 추가하는 것도 방법.

## 11.2.1 케라스를 사용한 전이 학습

- 출력 층만 제외하고 모든 층 재사용하여 model_B_on_A 만들기
    
    ```python
    model_A = tf.keras.models.load_model("my_model_A")
    model_B_on_A = tf.keras.Sequential(model_a.layeres[:-1])
    model_B_on_A.add(tf.keras.layers.Dense(1, activation="sigmoid"))
    ```
    
- model_B_on_A를 훈련할 때 model_A가 영향 받지 않게 하려면, model_A를 클론(clone)한 후 재사용하기
    
    ```python
    model_A_clone = tf.keras.models.clone_model(model_A) # 가중치 제외, 구조만 복제
    model_A_clone.set_weights(model_A.get_weights())     # 가중치를 수동으로 복사해야. 안하면 랜덤 초기화됨.
    ```
    
- model_B_on_A 훈련 시, 새로운 층이 랜덤하게 초기화되어 있어 처음 몇 번의 epoch 동안 큰 오차가 발생할 수 있다. 이를 방지하기 위해 처음 몇 번의 에포크 동안 재사용된 층을 동결하고, 새로운 층에게 적절한 가중치를 학습할 시간을 주어야.
    
    ```python
    for layer in model_B_on_A.layers[:-1]:
    		layer.trainable = False # 처음 몇 번의 에포크 동안 재사용된 층을 동결
    
    optimizer = tf.keras.optimizers.SGD(learning_rate=0.001)
    # 동결을 하거나 해제한 후, 반드시 모델 컴파일을 해야한다. (compile는 훈련될 가중치를 모으기 때문.)
    model_B_on_A.compile(loss="binary_crossentropy", optimizer=optimizer,
    											metrics=["accuracy"])
    history = model_B_on_A.fit(X_train_B, y_train_B, epochs=4,
    													 validation_data=(X_valid_B, y_valid_B))
    
    #----------------------------------------------------------------
    
    for layer in model_B_on_A.layers[:-1]:
    		layer.trainable = True
    		
    optimizer = tf.keras.optimizers.SGD(learning_rate=0.001)
    # 동결을 하거나 해제한 후, 반드시 모델 컴파일을 해야한다. (compile는 훈련될 가중치를 모으기 때문.)
    model_B_on_A.compile(loss="binary_crossentropy", optimizer=optimizer,
    											metrics=["accuracy"])
    history = model_B_on_A.fit(X_train_B, y_train_B, epochs=16,
    													 validation_data=(X_valid_B, y_valid_B))
    ```
    

<aside>
<img src="11%20%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8E%E1%85%B3%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%E1%84%86%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AE%E1%86%AB%E1%84%85%E1%85%A7%E1%86%AB%20a9b5a561a9e149b68f06f45841b15bc6/KakaoTalk_Photo_2024-05-04-19-46-47%201.png" alt="11%20%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8E%E1%85%B3%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%E1%84%86%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AE%E1%86%AB%E1%84%85%E1%85%A7%E1%86%AB%20a9b5a561a9e149b68f06f45841b15bc6/KakaoTalk_Photo_2024-05-04-19-46-47%201.png" width="40px" />     전이 학습(Transfer Learning)은 학습된 모델이나 그 모델의 일부를 새로운 작업에 적용하는 기술입니다. 전이 학습이 작은 fully connected network에서는 잘 작동하지 않는 이유는 주어진 작은 네트워크가 특정 작업에 특화되어 있기 때문입니다. 작은 네트워크는 제한된 데이터로 학습되었으며, 이는 작은 데이터셋에 대해 더 일반적인 패턴을 학습하기 어렵게 만듭니다.

    Fully connected network는 특정 '패턴'을 학습하기 때문에 이러한 패턴은 다른 작업에 유용하지 않을 수 있습니다. 따라서 작은 fully connected network에서는 전이 학습이 잘 작동하지 않을 수 있습니다.

    그러나 CNN(Convolutional Neural Network)과 같은 모델에서는 전이 학습이 더 잘 작동할 수 있습니다. CNN은 이미지와 같은 데이터에서 공간적인 특징을 감지하기 위해 설계되었으며, 이러한 특징은 다양한 작업에서 유용할 수 있습니다. 특히 아래쪽 층에서는 이미지의 일반적인 특성을 감지하는 경향이 있기 때문에, 이러한 층에서 전이 학습을 적용하는 것이 효과적일 수 있습니다.

    따라서 전이 학습은 작은 fully connected network보다 CNN과 같은 모델에서 보다 일반적인 특성을 학습한 경우에 더 잘 작동할 수 있습니다.

</aside>

## 11.2.2 비지도 사전 훈련_unsupervised pretraining

- 레이블된 훈련 데이터가 많지 않은 경우이고, 비슷한 작업에 대해 훈련된 모델을 찾을 수 없을 때.
- 레이블이 없는 훈련 샘플을 모으는 것은 비용이 적게 들지만, 레이블을 부여하는 것이 비싸다.
- 비지도 학습 과정
    1. 레이블되지 않은 훈련 데이터를 많이 모을 수 있다면, 이를 사용하여 오토인코더(autoencoder)나 GAN과 같은 비지도 학습 모델을 훈련할 수 있다.
        
        [Autoencoder](https://www.notion.so/Autoencoder-0ab39cbc7d024b8cbfffeffca0d291c7?pvs=21)
        
        [GAN](https://www.notion.so/GAN-815979b622e749db8b8acea665b32064?pvs=21)
        
    2. 그 다음, autoencoder나 GAN 판별자의 하위 층을 재사용하고 그 위에 새로운 작업에 맞는 출력 층을 추가할 수 있다,
    3. 그리고 지도학습으로(레이블된 훈련 샘플로) 최종 네트워크를 세밀하게 튜닝한다.

![Untitled](11%20%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8E%E1%85%B3%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%E1%84%86%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AE%E1%86%AB%E1%84%85%E1%85%A7%E1%86%AB%20a9b5a561a9e149b68f06f45841b15bc6/Untitled%2010.png)

## 11.2.3 보조 작업에서 사전 훈련

- 훈련 데이터를 쉽게 얻거나 생성할 수 있는 보조 작업에서 첫 번째 신경망을 훈련하고, 이 신경망의 하위 층을 실제 작업을 위해 사용한다.
    - ex1. 랜덤으로 많은 인물의 이미지를 수집해서 두 개의 다른 이미지가 같은 사람의 것인지 감지하는 첫 번째 신경망 훈련 가능.
    - ex2. 말뭉치(corpus) 다운로드 후 이 데이터에서 레이블된 데이터를 자동으로 생성. 일부 단어를  랜덤하게 지우고 누락된 단어를 예측하는 모델 훈련 가능
- 자기 지도 학습_self-supervised learning: 데이터에서 스스로 레이블을 생성하고 지도 학습 기법으로 레이블된 데이터셋에서 모델을 훈련하는 방법

# 11.3 고속 옵티마이저

- 이제까지 알아본 훈련 속도 높이는 방법
    1. 연결 가중치에 좋은 ‘초기화 전략’ 사용하기
    2. 좋은 ‘활성화 함수’ 사용하기
    3. 배치 정규화
    4. (보조 작업 or 비지도 학습으로 만들 수 있는) pretrained network의 일부 재사용하기
- 또 다른 훈련 속도 높이는 방법 → gradient opimizer 대신 다른 opimizer
    1. Momentum optimization
    2. 네스테로프 가속 경사
    3. AdaGrad
    4. RMSProp
    5. Adam
    6. Adam의 변형

## 11.3.1 모멘텀 최적화

$$
m \leftarrow \beta m - \eta \nabla_\theta J(\theta)
$$

$$
\theta \leftarrow \theta + m
$$

- 모멘텀 최적화 원리: 볼링공이 terminal velocity(종단 속도)에 도달할 때까지는 빠르게 가속됨.
    - 이전 그레디언트가 얼마였는지 반영함.
    - 그레디언트를 ‘속도’가 아니라 ‘가속도’로 사용하는 것.
    - 모멘텀이 너무 커지는 것을 막기 위해 하이퍼파라미터 $\beta$(모멘텀)를 사용함.
        - $\beta$가 커질수록 (저항이 없어질수록) 최적점 주위에서 수렴을 위한 진동이 심해진다.
        - 모멘텀 때문에 옵티마이저가 최적값에 안정되기 전까지 왔다갔다 할 수 있기 때문에, 시스템에 마찰이 조금 있는 것이 이러한 진동을 없애고 빠르게 수렴되는 데 도움이 된다.
    - 배치 정규화를 사용하지 않아 비용함수 그래프가 한쪽으로 길쭉한 모양인 경우, 표준 경사하강법은 좁고 긴 골짜기에서 오래 걸린다. 반면, 모멘텀 최적화는 골짜기를 따라 최적점에 도달할 때까지 점점 더 빨리 내려가기 때문에 큰 도움이 된다.
    - local minimum을 건너뛰는 데에도 도움이 됨.
    - 단점: 튜닝할 하이퍼파라미터(momentum)가 하나 더 늘어난다.

```python
optimizer = tf.keras.optimizers.SGD(learning_rate=0.001, momentum=0.9)
# 보통 모멘텀 0.9에서 잘 작동하며, 경사하강법보다 거의 항상 더 빠르다.
```

---

- 표준 경사하강법: 경사가 완만할 때는 작은 스텝, 가파를 때는 큰 스텝. 하지만 ‘속도’가 높아지지는 않음.
    - 결과적으로 모멘텀 최적화보다 최저점에 도달하는데 훨씬 느림.
    - 가중치를 갱신할 때, 이전의 그레디언트가 얼마였는지 고려하지 않음.

$$
\theta \leftarrow \theta - \eta \nabla_\theta J(\theta)
$$

## 11.3.2 네스테로프 가속 경사

## 11.3.3 AdaGrad

- 한쪽이 길쭉한 그릇 문제에서, 경사하강법보다 빨리 (처음부터) 전역 최적점 쪽으로 방향을 잡으면 좋지 않을까?
- AdaGrad는 가장 가파른 차원을 따라 그레디언트 벡터의 스케일을 감소시켜 이 문제를 해결.

---

1. 그레디언트의 제곱을 벡터 $s$에 누적한다. ($\otimes$는 원소별 곱셈)

$$
s \leftarrow s + \nabla_\theta J(\theta) \otimes \nabla_\theta J(\theta)
$$

1. 경사하강법과 같은데, 그레디언트 벡터를 $\sqrt{s + \epsilon}$ 으로 나누어 스케일을 조정함. ($\oslash$는 원소별 나눗셈, $\epsilon$은 일반적으로 $10^{-10}$)

$$
\theta \leftarrow \theta - \eta \nabla_\theta J(\theta) \oslash \sqrt{s + \epsilon}
$$

---

![Untitled](11%20%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8E%E1%85%B3%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%E1%84%86%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AE%E1%86%AB%E1%84%85%E1%85%A7%E1%86%AB%20a9b5a561a9e149b68f06f45841b15bc6/Untitled%2011.png)

- 학습률을 감소시키지만, (경사가 완만한 차원보다) 가파른 차원에 대해 더 빠르게 감소한다. = 적응적 학습률(adaptive learning curve)
    - 장점: 학습률 하이퍼파라미터 $\eta$(learning rate)를 덜 튜닝해도 된다.
- 단점: 학습률이 너무 감소하여 global minimum에 도착하기 전에 (너무 일찍) 최적화 알고리즘이 멈춘다.
    - 선형 회귀 같은 간단한 작업에만 효과적이고, 심층 신경망에는 사용하지 말아야.

---

```python
optimizer = tf.keras.optimizers.Adagrad(learning_rate=0.001)
```

## 11.3.4 RMSProp (AdaGrad의 변형)

- AdaGrad는 너무 빨리 느려져서 global minimum에 수렴하지 못하는 위험이 있음.
    - AdaGrad의 발전된 버전이므로 적응적 학습률 알고리즘이기 때문에, $\eta$를 튜닝할 필요가 적다.
- RMSProp은 훈련 시작부터의 모든 그레디언트가 아닌, 가장 최근 반복에서 비롯된 그레디언트만 누적함으로써 해결함.

---

(알고리즘 첫 번째에 지수 감소를 사용. (보통 감쇠율 $\rho$를 0.9로 설정함.))

$$
s \leftarrow \rho s + (1-\rho)\nabla_\theta J(\theta) \otimes \nabla_\theta J(\theta)
$$

$$
\theta \leftarrow \theta - \eta \nabla_\theta J(\theta) \oslash \sqrt{s + \epsilon}
$$

---

```python
optimizer = tf.keras.optimizers.RMSprop(learning_rate=0.001, rho=0.9)
# 튜닝할 하이퍼파라미터가 하나 더 생겼지만,
# 기본값이 잘 동작하는 경우가 많으므로 하이퍼파라미터 rho를 튜닝할 필요는 없다.
```

---

- AdaGrad < RMSProp < Adam

## 11.3.5 Adam (모멘텀 최적화 + RMSProp)

- Adam = Adaptive moment estimation (적응형 모멘트 추정)
    - 모멘텀 최적화 + RMSProp
        - 모멘텀 최적화: 지난 그레디언트의 지수 감소 평균(exponential decaying avg)를 따름.
        - RMSProp: 지난 그레디언트 제곱의 지수 감소된 평균을 따름.
    - 그레디언트 평균과 (평균이 0이 아닌) 분산에 대한 예측임.
        - first moment: 평균
        - second momnet: 분산
    - 적응형 학습률 알고리즘이기 때문에 하이퍼파라미터 $\eta$를 튜닝할 필요가 적다.

---

![Untitled](11%20%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8E%E1%85%B3%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%E1%84%86%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AE%E1%86%AB%E1%84%85%E1%85%A7%E1%86%AB%20a9b5a561a9e149b68f06f45841b15bc6/Untitled%2012.png)

- $\beta_1$: 모멘텀 최적화 $\beta$
- $\beta_2$: RMSProp의 $\rho$ (감쇠율)

---

```python
optimizer = tf.keras.optimizers.Adam(learning_rate=0.001, beta_1=0.9,
																     beta_2=0.999)
# 보통 0.9, 0.999로 초기화하는 경우가 많음 (기본값)
# 그래서 경사하강법보다 Adam이 사용하기 더 쉽다.
```

## 11.3.6 AdaMax (Adam의 변형)

## 11.3.7 Nadam (Adam의 변형)

- Adam + 네스테로프

## 11.3.8 AdamW (Adam의 변형)

![Untitled](11%20%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8E%E1%85%B3%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%E1%84%86%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AE%E1%86%AB%E1%84%85%E1%85%A7%E1%86%AB%20a9b5a561a9e149b68f06f45841b15bc6/Untitled%2013.png)

![Untitled](11%20%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8E%E1%85%B3%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%E1%84%86%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AE%E1%86%AB%E1%84%85%E1%85%A7%E1%86%AB%20a9b5a561a9e149b68f06f45841b15bc6/Untitled%2014.png)

## 11.3.9 학습률 스케줄링

![Untitled](11%20%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8E%E1%85%B3%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%E1%84%86%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AE%E1%86%AB%E1%84%85%E1%85%A7%E1%86%AB%20a9b5a561a9e149b68f06f45841b15bc6/Untitled%2015.png)

- 보라색: 처음에는 빠르게 진행, 최적점 근처에서 요동이 심해져 수렴하지 못함.

---

- 매우 작은 값에서 매우 큰 값까지 지수적으로 학습률을 증가시키면서 어떤 학습률이 좋은지 알아보면 된다.
- 그러나, 일정한 학습률보다… 큰 학습률로 시작하고 학습 속도가 느려질 때 학습률을 낮추면 더 빨리 좋은 솔루션을 발견할 수 있다. = 학습 스케줄

### 1) 거듭제곱 기반 스케줄링_power scheduling

![Untitled](11%20%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8E%E1%85%B3%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%E1%84%86%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AE%E1%86%AB%E1%84%85%E1%85%A7%E1%86%AB%20a9b5a561a9e149b68f06f45841b15bc6/Untitled%2016.png)

![Untitled](11%20%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8E%E1%85%B3%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%E1%84%86%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AE%E1%86%AB%E1%84%85%E1%85%A7%E1%86%AB%20a9b5a561a9e149b68f06f45841b15bc6/Untitled%2017.png)

### 2) 지수 기반 스케줄링_exponential scheduling

![Untitled](11%20%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8E%E1%85%B3%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%E1%84%86%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AE%E1%86%AB%E1%84%85%E1%85%A7%E1%86%AB%20a9b5a561a9e149b68f06f45841b15bc6/Untitled%2018.png)

![Untitled](11%20%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8E%E1%85%B3%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%E1%84%86%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AE%E1%86%AB%E1%84%85%E1%85%A7%E1%86%AB%20a9b5a561a9e149b68f06f45841b15bc6/Untitled%2019.png)

- `tf.keras.callbacks.LearningRateScheduler`

![Untitled](11%20%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8E%E1%85%B3%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%E1%84%86%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AE%E1%86%AB%E1%84%85%E1%85%A7%E1%86%AB%20a9b5a561a9e149b68f06f45841b15bc6/Untitled%2020.png)

- `tf.keras.optimizers.schedules` 에 있는 스케줄 중 하나를 사용해 학습률을 정의하고 optimizer에 전달하기.
    - epoch가 아니라, 매 스텝마다 학습률을 업데이트한다.

![exponential_decay_fn()과 동일한 지수 기반 스케줄링을 구현하는 방법임.](11%20%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8E%E1%85%B3%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%E1%84%86%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AE%E1%86%AB%E1%84%85%E1%85%A7%E1%86%AB%20a9b5a561a9e149b68f06f45841b15bc6/Untitled%2021.png)

exponential_decay_fn()과 동일한 지수 기반 스케줄링을 구현하는 방법임.

<aside>
<img src="11%20%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8E%E1%85%B3%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%E1%84%86%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AE%E1%86%AB%E1%84%85%E1%85%A7%E1%86%AB%20a9b5a561a9e149b68f06f45841b15bc6/KakaoTalk_Photo_2024-05-04-19-46-47%201.png" alt="11%20%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8E%E1%85%B3%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%E1%84%86%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AE%E1%86%AB%E1%84%85%E1%85%A7%E1%86%AB%20a9b5a561a9e149b68f06f45841b15bc6/KakaoTalk_Photo_2024-05-04-19-46-47%201.png" width="40px" /> 콜백(callback)은 TensorFlow와 같은 딥러닝 프레임워크에서 모델 학습 과정 중에 특정 이벤트가 발생했을 때 실행되는 사용자 지정 함수입니다. 콜백은 모델 학습을 모니터링하고, 중지하거나 수정하는 데 사용됩니다. 주요 이벤트로는 에포크(epoch)의 시작 또는 종료, 배치(batch)의 시작 또는 종료, 학습률의 조정 등이 있습니다.

콜백은 다음과 같은 목적으로 사용될 수 있습니다:

1. **모델 체크포인트 저장**: 특정 조건이 충족되었을 때 모델의 가중치를 저장합니다. 이렇게 함으로써 학습 중간에 모델의 상태를 저장하고, 이후에 모델을 재사용하거나 학습을 재개할 수 있습니다.
2. **조기 종료(early stopping)**: 검증 손실이 더 이상 개선되지 않을 때 학습을 중지합니다. 이렇게 함으로써 과적합을 방지하고 학습 속도를 높일 수 있습니다.
3. **학습률 조정**: 학습률을 동적으로 조정하여 학습 과정을 최적화합니다. 학습률을 점진적으로 감소시키거나 증가시키는 등의 전략을 사용할 수 있습니다.
4. **로그 기록**: 학습 중에 발생하는 다양한 지표를 기록하고, 그래프나 시각화 도구를 사용하여 학습 과정을 모니터링합니다.
5. **사용자 정의 동작**: 사용자가 정의한 특정 동작을 수행합니다. 예를 들어, 특정 지표가 특정 임계값을 초과하거나 미만할 때 알림을 보내는 등의 동작을 수행할 수 있습니다.

콜백은 TensorFlow의 **`tf.keras.callbacks`** 모듈에서 제공되며, 사용자 정의 콜백을 작성하여 필요한 동작을 구현할 수도 있습니다. 종종 콜백은 모델 학습 과정을 효율적으로 관리하고, 모델의 성능을 향상시키는 데 중요한 역할을 합니다.

</aside>

### 3) 구간별 고정 스케줄링_piecewise constant scheduling

![Untitled](11%20%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8E%E1%85%B3%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%E1%84%86%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AE%E1%86%AB%E1%84%85%E1%85%A7%E1%86%AB%20a9b5a561a9e149b68f06f45841b15bc6/Untitled%2022.png)

![Untitled](11%20%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8E%E1%85%B3%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%E1%84%86%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AE%E1%86%AB%E1%84%85%E1%85%A7%E1%86%AB%20a9b5a561a9e149b68f06f45841b15bc6/Untitled%2023.png)

- 지수 기반 스케줄링과 마찬가지로, piecewise_constant_fn 함수로 LearningRateScheduler 콜백을 만들어 fit() 메서드에 전달한다.

### 4) 성능 기반 스케줄링_performance scheduling

![Untitled](11%20%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8E%E1%85%B3%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%E1%84%86%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AE%E1%86%AB%E1%84%85%E1%85%A7%E1%86%AB%20a9b5a561a9e149b68f06f45841b15bc6/Untitled%2024.png)

- `tf.keras.callbacks.ReduceLROnPlateau`

![검증 손실(validation loss)이 5번의 연속적인 epoch 동안 향상되지 않을 때마다 학습률에 0.5를 곱한다.](11%20%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8E%E1%85%B3%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%E1%84%86%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AE%E1%86%AB%E1%84%85%E1%85%A7%E1%86%AB%20a9b5a561a9e149b68f06f45841b15bc6/Untitled%2025.png)

검증 손실(validation loss)이 5번의 연속적인 epoch 동안 향상되지 않을 때마다 학습률에 0.5를 곱한다.

### 5) 1사이클 스케줄링

- 학습률

![Untitled](11%20%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8E%E1%85%B3%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%E1%84%86%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AE%E1%86%AB%E1%84%85%E1%85%A7%E1%86%AB%20a9b5a561a9e149b68f06f45841b15bc6/Untitled%2026.png)

![Untitled](11%20%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8E%E1%85%B3%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%E1%84%86%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AE%E1%86%AB%E1%84%85%E1%85%A7%E1%86%AB%20a9b5a561a9e149b68f06f45841b15bc6/Untitled%2027.png)

- 모멘텀

![Untitled](11%20%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8E%E1%85%B3%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%E1%84%86%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AE%E1%86%AB%E1%84%85%E1%85%A7%E1%86%AB%20a9b5a561a9e149b68f06f45841b15bc6/Untitled%2028.png)

- 성능

![Untitled](11%20%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8E%E1%85%B3%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%E1%84%86%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AE%E1%86%AB%E1%84%85%E1%85%A7%E1%86%AB%20a9b5a561a9e149b68f06f45841b15bc6/Untitled%2029.png)

---

- keras에서 1사이클 스케줄링을 지원하지는 않지만, 매 반복마다 학습률을 조정하는 사용자 정의 콜백을 30줄 미만의 코드로 만들 수 있다.

```python
import tensorflow.keras.backend as K

class OneCycleScheduler(keras.callbacks.Callback):
    def __init__(self, iterations, max_rate, start_rate=None,
                 last_iterations=None, last_rate=None):
        """
        :param iterations: 총 반복 횟수
        :param max_rate: 최대 학습률
        :param start_rate: 시작 학습률 (기본값: 최대 학습률의 1/10)
        :param last_iterations: 마지막 일부 반복 횟수 (기본값: 총 반복 횟수의 1/10 + 1)
        :param last_rate: 마지막 학습률 (기본값: 시작 학습률의 1/1000)
        """
        self.iterations = iterations
        self.max_rate = max_rate
        self.start_rate = start_rate or max_rate / 10
        self.last_iterations = last_iterations or iterations // 10 + 1
        self.half_iteration = (iterations - self.last_iterations) // 2
        self.last_rate = last_rate or self.start_rate / 1000
        self.iteration = 0
        
    def _interpolate(self, iter1, iter2, rate1, rate2):
        """
        두 점 사이에서 현재 반복 횟수에 따라 학습률을 보간하는 함수
        :param iter1: 시작 반복 횟수
        :param iter2: 종료 반복 횟수
        :param rate1: 시작 학습률
        :param rate2: 종료 학습률
        :return: 보간된 학습률
        """
        return ((rate2 - rate1) * (self.iteration - iter1)
                / (iter2 - iter1) + rate1)
                
    def on_batch_begin(self, batch, logs):
        """
        각 배치의 학습이 시작되기 전에 호출되는 메서드
        :param batch: 현재 배치 번호
        :param logs: 현재 학습 로그
        """
        if self.iteration < self.half_iteration:
            # 반복 횟수가 절반 이전인 경우, 최대 학습률에서 시작 학습률까지 선형적으로 증가
            rate = self._interpolate(0, self.half_iteration, self.start_rate, self.max_rate)
        elif self.iteration < 2 * self.half_iteration:
            # 반복 횟수가 절반 이후인 경우, 시작 학습률에서 최대 학습률까지 선형적으로 감소
            rate = self._interpolate(self.half_iteration, 2 * self.half_iteration,
                                     self.max_rate, self.start_rate)
        else:
            # 마지막 일부 반복인 경우, 시작 학습률에서 아주 작은 값까지 선형적으로 감소
            rate = self._interpolate(2 * self.half_iteration, self.iterations,
                                     self.start_rate, self.last_rate)
            rate = max(rate, self.last_rate)  # 최소값을 설정해줌
        self.iteration += 1
        K.set_value(self.model.optimizer.lr, rate)  # 모델의 학습률 업데이트
```

# 11.4 규제를 사용해 과대적합 피하기

- 심층 신경망 = 수많은 파라미터 = 높은 자유도 = 복잡한 데이터셋 학습 가능 = 네트워크를 훈련 세트에 과대적합 되기 쉽게 만듦 = 규제 필요
- 이미 알아본 규제 방법들
    - 조기 종료
    - 배치 정규화: 불안정한 그레디언트 문제를 해결하기 위해 고안되었지만, 꽤 괜찮은 규제 방법으로 사용될 수 있음.

## 11.4.1 l1과 l2 규제

- $l_1$: (많은 가중치가 0인) 희소 모델 만들기
- $l_2$: 신경망의 연결 가중치 제한
    
    ![Untitled](11%20%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8E%E1%85%B3%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%E1%84%86%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AE%E1%86%AB%E1%84%85%E1%85%A7%E1%86%AB%20a9b5a561a9e149b68f06f45841b15bc6/Untitled%2030.png)
    

```python
layer = tf.keras.layers.Dense(100, activation="relu",
															kernel_initializer="he_normal",
															kernel_regularizer=tf.keras.regularizers.l2(0.01))
# keras.regularizers.l1()
# keras.regularizers.l1_l2(): 둘 다 필요할 경우 (ElasticNet)
```

---

- 일반적으로 네트워크의 모든 은닉층에 동일한 ‘활성화 함수’, 동일한 ‘초기화 전략’을 사용하거나 모든 층에 동일한 ‘규제’를 사용함.
    - 반복문 사용
    - functools.partial() 함수를 사용
        
        ```python
        
        # RegularizedDense를 부분 적용하여 사용하기 위한 함수
        RegularizedDense = partial(Dense, activation="relu",
        													 kernel_initializer="he_normal",
        													 kernel_regularizer=tf.keras.regularizers.l2(0.01))
        
        # 모델 정의
        model = Sequential([
            Flatten(input_shape=(28, 28)),  # 입력 데이터를 28x28의 1차원 벡터로 펼침
            RegularizedDense(100),  # RegularizedDense 레이어 사용하여 100개의 뉴런을 가진 은닉층 생성
            RegularizedDense(100),  # 또 다른 RegularizedDense 레이어를 사용하여 100개의 뉴런을 가진 은닉층 생성
            RegularizedDense(10, activation="softmax")  # 마지막 출력층, 10개의 클래스를 분류하는 softmax 활성화 함수 사용
        ])
        ```
        

## 11.4.2 드롭아웃

- 매 훈련 스템에서 각 뉴런(입력 뉴런은 포함하고, 출력 뉴런은 제외)은 임시적으로 드롭아웃될 확률 $p$를 가진다.
- 이번 훈련 스텝에서 무시된 뉴런들은 다음 스텝에는 활성화될 수 있음.
- $p$: 드롭아웃 비율_dropout rate
    - 보통 10~50%
        - RNN: 20~30%
        - CNN: 40~50%

---

![Untitled](11%20%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8E%E1%85%B3%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%E1%84%86%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AE%E1%86%AB%E1%84%85%E1%85%A7%E1%86%AB%20a9b5a561a9e149b68f06f45841b15bc6/Untitled%2031.png)

---

- 드롭아웃의 이해 (1)
    1. 드롭아웃으로 훈련된 뉴런은 이웃한 뉴런에 맞추어 적응할 수 없다.
        
        즉, 가능한 한 자기 자신이 유용해져야 하는 것이다.
        
    2. 그리고, 몇 개의 입력 뉴런에만 지나치게 의존할 수도 없다.
        
        즉, 모든 입력 뉴런에 주의를 기울여야한다.
        
    3. 그러므로 입력값의 작은 변화에 덜 민감해진다.
    4. 결국 더 안정적인 네트워크가 되어 일반화 성능이 좋아진다.
- 드롭아웃의 이해 (2)
    1. 각 훈련 스텝에서 고유한 네트워크가 생성된다고 생각하자.
    2. 10,000번의 훈련 스텝을 진행하면 10,000개의 다른 신경망을 훈련하게 된다.
    3. 이 신경망은 대부분의 가중치를 공유하고 있기 때문에 아주 독립적이지 않다.
    4. 하지만 그럼에도 모두 다르다.
    5. 결과적으로, 만들어진 신경망은 이 모든 ‘신경망을 평균한 앙상블’로 볼 수 있다.

---

- 일반적으로 (출력 층을 제외한) 맨 위층부터 3번째 층까지의 뉴런에만 드롭아웃을 적용한다.

---

- $p$ = 75%로 하면, 평균적으로 뉴런의 25%만 훈련하는 동안 작동한다.
- 훈련이 끝나면 각 뉴런이 훈련할 때보다 4배가 많은 입력에 연결되는 것이다.
- 이런 점을 보상하기 위해, 각 뉴런의 연결 가중치에 4를 곱해야 한다.
    - 그렇지 않으면, 훈련 중 & 훈련 후에 각각 다른 데이터를 만나게 되므로 제대로 작동하지 않을 것이다.
- 일반적으로, 훈련하는 동안 각 입력 연결 가중치를 ‘보존 확률(keep probability)’ $(1-p)$로 나눠야 한다.

---

```python
model = tf.keras.Sequential([
    tf.keras.layers.Flatten(input_shape=(28, 28)),  # 입력 데이터를 28x28의 1차원 벡터로 펼침
    
    tf.keras.layers.Dropout(0.2),  # 드롭아웃 비율이 0.2인 드롭아웃 레이어 추가
    tf.keras.layers.Dense(100, activation='relu', kernel_initializer='he_normal'),  # 100개의 뉴런을 가진 ReLU 활성화 함수와 He 초기화를 사용하는 fully connected layer 추가
    
    tf.keras.layers.Dropout(0.2),  # 드롭아웃 비율이 0.2인 드롭아웃 레이어 추가
    tf.keras.layers.Dense(100, activation='relu', kernel_initializer='he_normal'),  # 또 다른 100개의 뉴런을 가진 ReLU 활성화 함수와 He 초기화를 사용하는 fully connected layer 추가
    
    tf.keras.layers.Dropout(0.2),  # 드롭아웃 비율이 0.2인 드롭아웃 레이어 추가
    tf.keras.layers.Dense(10, activation='softmax')  # 출력층, 10개의 클래스를 분류하는 softmax 활성화 함수 사용
])
```

---

- 드롭아웃 비율
    - 드롭아웃 비율 UP
        - 모델이 과대적합 된 경우
        - 층이 클  때
    - 드롭아웃 비율 DOWN
        - 모델이 훈련 세트에 과소 적합된 경우
    - 층이 작을 때
- 최신 신경망 구조는 마지막 은닉층 뒤에만 드롭아웃을 사용.
- 드롭아웃은 수렴을 느리게 만들지만, 적절하게 튜닝하면 더 좋은 모델을 만들기에 대규모 모델일 경우 추가적인 시간과 노력을 기울일 가치가 있다.

---

![Untitled](11%20%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8E%E1%85%B3%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%E1%84%86%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AE%E1%86%AB%E1%84%85%E1%85%A7%E1%86%AB%20a9b5a561a9e149b68f06f45841b15bc6/Untitled%2032.png)

## 11.4.3 몬테 카를로 드롭아웃

- 몬테 카를로 드롭아웃(MC 드롭아웃): 훈련된 드롭아웃 모델을 재훈련하거나 전혀 수정하지 않고 성능을 크게 향상시킬 수 있음.
    - 모델의 불확실성을 더 잘 측정할 수 있음.

```python
import numpy as np

y_probas = np.stack([model(X_test, training=True) # training=True로 Dropout 층이 활성화됨.
										for sample in range(100)])
 # 테스트 세트에서 100개의 예측을 만들고 평균을 계산.
y_proba = y_probas.mean(axis=0)
```

## 11.4.4 맥스-노름 규제

- 각각의 뉴런에 대해 입력의 연결 가중치 $w$가 $\lVert w \rVert_2 \le r$이 되도록 제한한다.
    - $r$: 맥스-노름 하이퍼파라미터
        - $r$을 줄이면 규제 양이 증가해서 과대적합을 감소시키는 데 도움.
        - 맥스-노름 규제는 (배치 정규화 사용 안했을 때) 불안정한 그레디언트 문제를 완화하는 데 도움.
    - $\lVert \cdot \rVert_2$ 는 $l_2$ 노름을 나타낸다.
- 맥스-노름 규제는 전체 손실함수에 ‘규제 손실항’을 추가하지 않는다.
    - 대신 일반적으로 매 훈련 스텝이 끝나고 $\lVert w \rVert_2$ 를 계산하고, 필요하면 $w$의 스케일을 조정한다. ($w \leftarrow w\frac{r}{\lVert w \rVert_2}$
    )

```python
dense = tf.keras.layers.Dense(
		100, activation="relu", kernel_initializer="he_normal",
		kernel_constraint=tf.keras.constraints.max_norm(1.))
```

- max_norm()은 기본값이 0인 axis 매개변수를 가진다.
    - Dense 층은 일반적으로 [샘플 개수, 뉴런 개수] 크기의 가중치를 가진다.
    - axis=0을 사용하면 맥스-노름 규제는 각 뉴런의 가중치 벡터에 독립적으로 적용된다.
    - Convolution layer는 일반적으로 [샘플 개수, 높이, 너비, 채널 개수] 크기의 가중치를 가지기 때문에, axis=[0,1,2]로 지정하면 채널축에 독립적으로 적용된다.

## 11.5 요약 및 실용적인 가이드라인

![Untitled](11%20%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8E%E1%85%B3%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%E1%84%86%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AE%E1%86%AB%E1%84%85%E1%85%A7%E1%86%AB%20a9b5a561a9e149b68f06f45841b15bc6/Untitled%2033.png)

![Untitled](11%20%E1%84%89%E1%85%B5%E1%86%B7%E1%84%8E%E1%85%B3%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%E1%84%86%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AE%E1%86%AB%E1%84%85%E1%85%A7%E1%86%AB%20a9b5a561a9e149b68f06f45841b15bc6/Untitled%2034.png)

# 연습문제

### 1) 글로럿 초기화와 He 초기화가 해결하고자 하는 문제는 무엇인가요?

### 2) He 초기화를 사용하여 랜덤으로 선택한 값이라면 모든 가중치를 같은 값으로 초기화해도 괜찮을까요?

### 3) 편향을 0으로 초기화해도 괜찮을까요?

### 4) 어떤 경우에 이 장에서 언급한 활성화 함수를 사용하나요?

### 5) SGD 옵티마이저를 사용할 때 momentum 하이퍼파라미터를 너무 1에 가깝게 하면(ex. 0/99999) 어떤 일이 일어날까요?

### 6) 희소 모델을 만들 수 있는 3가지 방법은 무엇인가요?

### 7) 드롭아웃이 훈련 속도를 느리게 만드나요? 추론(새로운 샘플에 대한 예측을 만드는 것)도 느리게 만드나요? MC 드롭아웃은 어떤가요?

### 8) CIFAR10 이미지 데이터셋에 심층 신경망을 훈련해보세요.

1. 100개 뉴런을 가진 은닉 층 20개로 심층 신경망을 만들어보세요(너무 많은 것 같지만 이 연습문제의 핵심입니다). He 초기화와 Swish 활성화 함수를 사용하세요.
2. Nadam 옵티마이저와 조기 종료를 사용하여 CIFAR10 데이터셋에 이 네트워크를 훈련하세요. tf.keras.datasets.cifar10.load_data()를 사용하여 데이터를 적재할 수 있습니다. 이 데이터셋은 10개의 클래스와 32x32 크기의 컬러 이미지 60,000개로 구성됩니다.(50,000개는 훈련, 10,000개는 테스트), 따라서 10개의 뉴런과 소프트맥스 활성화 함수를 사용하는 출력 층이 필요합니다. 모델 구조와 하이퍼파라미터를 바꿀 때마다 적절한 학습률을 찾아야 한다는 것을 기억하세요.
3. 배치 정규화를 추가하고 학습 곡선을 비교해보세요. 이전보다 빠르게 수렴하나요? 더 좋은 모델이 만들어지나요? 훈련 속도에는 어떤 영향을 미치나요?
4. 배치 정규화를 SELU로 바꾸어보세요. 네트워크가 자기 정규화하기 위해 필요한 변경 사항을 적용해보세요 (입력 특성 표준화, 르쿤 정규 분포 초기화, 완전 연결 층만 순차적으 로 쌓은 심층 신경망 등).
5. 알파 드롭아웃으로 모델에 규제를 적용해보세요. 그다음 모델을 다시 훈련하지 않고 MC 드롭아웃으로 더 높은 정확도를 얻을 수 있는지 확인해보세요.
6. 1사이클 스케줄링으로 모델을 다시 훈련하고 훈련 속도와 모델 정확도가 향상되는지 확 인해보세요.